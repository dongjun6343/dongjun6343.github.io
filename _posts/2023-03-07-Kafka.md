---
layout: post
title:  "[TIL]Kafka란?"
author: "dongurijun"
tags: ["Kafka"]
---

프로젝트를 하면서 카프카 대한 내용이 계속 나오면서 

정리를 한번 해야겠다고 생각만 하다가

(예전에 비동기메세징이라는 것에 대해서 한번 정리를 해봤지만..)

이번에 전체적으로 정리를 해봤다.




### Kafka란?
아파치 카프카란 분산 환경의 유연성과 확장성을 위해 설계된 발행(Publish)/구독(Subscribe) 모델의 메세지 큐 시스템이다.


### Kafka와 전통적인 큐 시스템의 차이

- Kafka는 클러스터로 구성되며 확장 가능한 분산 시스템으로 실행된다.

즉, 각 노드에 대한 장애 대응성을 가지고 있고, 탄력적으로 확장할 수 있어서

중심 플랫폼의 역할을 수행하기에 적합하다.

- Kafka의 데이터는 기본적으로 `디스크 기반 파일시스템`을 이용한다.

모든 데이터는 복제되고 영구적이며 원하는 만큼 보존된다.

- 단순한 메시지 헤더를 지닌 TCP 기반의 프로토콜을 사용하여

오버헤드가 적고, 대용량 실시간 로그 처리에 특화되어 있다.

- 배치형태로 다수의 메시지를 송수신가능하여 TCP/IP 왕복횟수를 줄일 수 있다.


### Kafka 구성
Kafka는 기본적으로 Zookeeper , Broker, Producer , Cunsumer로 구성된다.

{% highlight java %}

					Zookeeper

Producer	->	     			                    ->	 Cunsumer
Producer	->	                Broker		            ->	 Cunsumer
Producer	->	     			                    ->	 Cunsumer


{% endhighlight %}

해당 Kafka를 중심으로 다수의 Producer와 Consumer가 메세지를 교환하게 된다.

이러한 분산 시스템으로 구성된 Kafka를 효율적으로 코디네이션 하기 위한 서비스가 `Zookeeper` 이다.

Zookeeper는 kafka 서비스의 일부분이며

Producer와 Cunsumer는 Kafka Broker를 통해 메세지를 주고 받으며

Zookeeper는 브로커와 토픽의 메타데이터, 컨슈머의 메타데이터와 파티션 오프셋 등을 모두 관리한다.



### Kafka 용어정리

### 1. 메시지란?

Kafka에서는 데이터의 기본 단위를 메시지라고 한다. 메시지는 기본적으로 키,벨류의 형태이다.

실제로 연동되는 데이터(payload)는 Value에 포함이 된다.

메시지의 Key는 1. 메시지를 식별하는 추가 정보를 갖는것과  2. 토픽의 여러 파티션 중 메시지에 쓰여질 파티션을 결정한다.

{% highlight java %}

Key를 가지는 메시지

ProducerRecord<String, String> record = new ProducerRecord<>("TopicName", "Key", "Value");

Key를 갖지 않는 메시지

ProducerRecord<String, String> record = new ProducerRecord<>("TopicName", "Value");

{% endhighlight %}

### 2. 토픽과 파티션이란?

Kafka의 메시지는 토픽으로 분류된다. 토픽은 DB의 테이블과 유사한 개념이라고 생각!

하나의 토픽은 여러개의 파티션으로 구성될 수 있고, 메시지는 파티션에 추가되는 형태.

파티션별로 메시지가 쓰여지고 읽어지기 떄문에 `파티션의 개수를 늘려 병렬 처리를 통한 데이터 처리 성능을 향상 시킬 수 있다.`

메시지는 파티션의 가장 먼저 수록된 메시지부터 읽게 되며(큐), 따라서 파티션 단위의 메시지 읽기 순서는 보장된다.

즉, 파티션 하나로 구성된 토픽은 메시지 처리 순서가 보장된다.

#### 하지만 토픽에 파티션이 두 개 이상이라면??

파티션별 메시지 처리 속도가 다를 수 있기 때문에 토픽단위의 메시지 읽기 순서는 보장되지 않는다.

`메시지의 처리 성능 향상과 파티션 개수 증가와 순서 보장을 모두 필요하다면`

메시지의 키와 파티셔너를 통해 순서가 보장되어야 하는 단위를 설정할 수 있다.

#### 정리

예를 들어 파티션이 여러개인 경우 토픽의 메시지 순서는 보장되지 않는다.

하지만 카프카의 기본 파티셔너를 사용하면서 Key에 사용자ID값을 세팅하면 사용자ID에 따른 메시지 순서는 보장된다.

### 3. 프로듀서와 컨슈머

Kafka 시스템의 사용자는 기본적으로 프로듀서와 컨슈머의 형태이다.

프로듀서는 새로운 메시지를 Kafka 시스템의 특정 토픽에 생성하며 이것을 발행(Publish)라고 한다.

여러 프로듀서가 많은 토픽을 사용해도 Kafka는 무리 없이 처리가 가능하며, 많은 컨슈머가 상호 간섭 없이 어떤 메시지도 읽을 수 있다.

### 4. 브로커와 클러스터

하나의 kafka 서버를 브로커라고 한다.

브로커는 프로듀서로부터 메시지를 수신하고, 오프셋을 지정한 뒤 해당 메시지를 디스크에 저장한다.

또한 컨슈머의 파티션 읽기 요청에 응답하고 디스크에 수록된 메시지를 전송한다.

Kafka의 브로커는 클러스터의 일부이며, 여러개의 브로커가 하나의 클러스터에 포함될 수 있고,

그 중 하나는 자동으로 클러스터 컨트롤러의 기능을 수행한다.

컨트롤러는 같은 클러스터의 각 브로커에 담당 파티션을 할당하고 브로커들이 정상적으로 동작하는지 모니터링을 한다.

이 경우 해당 파티션이 복제되어 파티션의 메시지는 중복으로 저장되지만, 관런 브로커에 장애가 생기면

다른 브로커가 소유권을 인계받아 그 파티션을 처리하여 메시징 서비스가 중단되지 않게 된다.

### 5. 컨슈머 그룹

Kafka에서 컨슈머 그룹은 파티션 읽기 행위를 수행하는 단위이다.

Kafka의 컨슈머들은 컨슈머 그룹에 속하며, 메시지의 읽은 위치를 나타내는 오프셋은 컨슈머 그룹단위로 관리된다.

#### 왜 컨슈머 그룹을 사용하는 것일까?

만약 컨슈머의 메시지를 읽고 처리하는 속도보다 프로듀서가 토픽에 메시지를 쓰는 속도가 빠르다면

메시지가 점점 쌓이게 될 것이다. 이럴 경우 읽기 처리 성능을 향상시킬 필요가 있다.

따라서 컨슈머 자체의 성능을 향샹시키는 방법도 있겠지만,

컨슈머의 그룹의 개념을 적용해서 컨슈머를 추가함으로써 간단히 컨슈머의 확장에 따른 읽기 처리 성능을 향상시킬 수 있다.

### 6. 커밋과 오프셋

컨슈머는 하나 이상의 토픽을 구독하여 파티션별 메시지가 생성된 순서대로 읽으며,

해당 컨슈머가 읽은 메시지의 위치를 `오프셋`이라는 지속적으로 증가하는 정수값인 메타데이터를 통해 관리한다.

이러한 파티션 내의 오프셋을 변경하는 것을 커밋이라고 한다.

컨슈머는 오프셋을 기준으로 읽은/읽지않은 메시지를 추적할 수 있다.

따라서 어디서부터 읽어야 하는지에 대한 정보는 오프셋을 통해 알아낼 수 있다.


### 참고서적
    
    아파치 카프카 애플리케이션 프로그래밍 with 자바 - 최원영 저



