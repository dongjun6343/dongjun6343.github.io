---
layout: post
title:  "토비의 스프링3.1을 읽고 - 1장 정리"
author: "dongurijun"
tags: ["토비의 스프링"]
---


### 제어의 역전(Inversion of Control)

성격이 다른 책임이나 관심사는 분리하자

현재 분리될 기능은 UserDao와 ConnectionMaker구현 클래스의 오브젝트를 만드는 것과

그렇게 만들어진 두개의 오브젝트가 연결돼서 사용될 수 있도록 관계를 맺어준다.

분리시킬 기능을 담당할 클래스(객체의 생성 방법을 결정하고 만들어진 오브젝트를 돌려주는 것)를 생성한다.
    
    => 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 분리한다.
    => `팩토리`

{% highlight java %}

// UserDao의 생성 책임을 맡은 팩토리 클래스
public class DaoFactory{
    public UserDao userDao(){
    // 팩토리의 메소드는 UserDao 타입의 오브젝트를 어떻게 만들고 어떻게 준비시킬지 결정한다.
    ConnectionMaker connectionMaker = new DConnectionMaker();
    UserDao userDao = new UserDao(connectionMaker);
    return userDao;
    }
}

{% endhighlight %}


=> UserDaoTest는 DaoFactory(팩토리)로 부터 UserDao 오브젝트를 받아서 사용하기만 하면 된다.

(어떻게 만들어지는지 어떻게 호출하는지는 Test가 알 필요가 없다. ==> Test에만 집중!)

만약 DaoFactory에 UserDao가 아닌 다른 DAO의 생성 기능을 넣으면 어떻게 될까?

ex) AccountDAO, MessageDAO


{% highlight java %}

//DAO 생성 메서드의 추가로 인해 발생하는 중복
public class DaoFactory{

    public UserDao userDao(){
        return new UserDao(new DConnectionMaker());
    }

	public AccountDAO accountDAO(){
		return new AccountDAO(new DConnectionMaker());
	}
	
	public MessageDAO messageDAO(){
		return new MessageDAO(new DConnectionMaker());
	}

}

문제점 : DAO가 많아지면 ConnectionMaker의 구현 클래스를 바꿀때마다 모든 메소드를 수정해야함.

//생성 오브젝트 코드 수정
public class DaoFactory{

    public UserDao userDao(){
        return new UserDao(connectionMaker());
    }

	public AccountDAO accountDAO(){
		return new AccountDAO(connectionMaker());
	}
	
	public MessageDAO messageDAO(){
		return new MessageDAO(connectionMaker());
	}
	
	public ConnectionMaker connectionMaker(){
		return new DConnectionMaker();
	}
}

{% endhighlight %}

제어의 역전이란?

오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다.

당연히 생성하지도 않는다.

또 자신이 어떻게 만들어지고 어디서 사용되는지 알 수 없다.

모든 제어의 권한을 자신이 아닌 다른 대상에게 위임한다.

프레임워크와 라이브러리의 차이점은

라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다.

반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다.(프레임워크는 제어의 역전 개념이 적용된 대표적인 기술이다.)

우리가 만든 UserDao와 DaoFactory에도 제어의 역전이 있다.

원래는 ConnectionMaker의 구현 클래스를 결정하는 것은 UserDao에 있었는데 지금은 DaoFactory에 있다.

ConnectionMaker 구현 클래스를 만들고 사용할지를 결정할 권한을 DaoFactory에 넘겼으니 UserDao는 수동적인 존재가 됐다.

유연하고 확장 가능한 구조로 만들기 위해 DaoFactory를 도입했던 과정이 IoC적용 과정이였다.
