---
layout: post
title:  "JPA 영속성 컨텍스트 및 연관관계"
author: "dongurijun"
tags: ["TIL"]
---

회사의 코드를 리펙토링 하면서 jpa에 대해서 다시 한번 공부를 하면서 정리를 해봤다!

``` java

@Test
@Transcational -- 스프링꺼 사용 권장.

-> @Transcational이 테스트에 있으면 테스트가 끝난 후 디비를 롤백시킨다!
롤백을 시키지 않으려면 @Rollback(false)

같은 트랜잭션에서 저장하고 조회한다면, 영속성컨텍스트에서 같은 엔티티라고 생각.
영속성컨텍스트에 있네? -> 1차 캐시에서 꺼냄.

[영속성 컨텍스트란?]
영속성 컨텐스트란 엔티티를 영구 저장하는 환경이라는 뜻이다.
엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 
엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다. (영속성 컨텍스트는 엔티티의 동일성을 보장한다.)

1. 쿼리파라미터를 찍는 방법
 - logging:
			level: 
			org.hibernate.type:trace


2. 쿼리파라미터를 찍는 방법
P6Spy (외부라이브러리 추가)

내장타입
@Embedded
@Embeddable
- 두개를 함께쓰자. (나말고 다른 개발자들을 위해서.)


양방향관계
@ManyToOne @OneToMany (주인관계를 맞춰야함)
FK는 하나다!

일대다관계
Member - Order

FK 업데이트는 둘중에 하나만 하기로 약속했다.
둘중에 하나를 연관관계 주인으로 잡으면 된다.
FK가 가까운곳으로 하면 된다. ( => Order)

Member
@OneToMany(mappedby = "member") - 읽기전용이 된다.

Order
@ManyToOne
@JoinColumn(name="member_id") - 연관관계 주인

내 생각 정리!
부모 자식의 관계를 생각해보면, 멤버는 부모고 주문은 자식이다. 
FK는 부모에 있을 수 없다. 자식에게 있는법! 
따라서 주문에 member_id라는 FK가 있고, 해당 FK키는 주문에 가까이 있으므로
주문에서 연관관계 주인을 걸어야한다!

--- 

1대1 관계일 경우 
오더 - 딜리버리

JPA? - FK를 어디에 둬야하는가?
access를 많이 하는곳에서 FK를 두는게 좋다.

연관관계 주인을 정한다면? FK가 가까운곳! 
-> ORDER에 연관관계 주인을 걸면된다.


실무에서는 ManyToMany를 사용하지말자..! (컬럼 추가가 어렵다.)

[중요!!] 실무에서는 모든 연관관계는 지연로딩(LAZY)로 설정해야한다.
즉시로딩은 예측이 어렵고 특히, JPQL을 실행할때 N+1 문제가 발생한다.
@XToOne관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야한다.
(@OneToX은 기본패치 전략이 LAZY이다 -> 따라서 기본으로 냅두면 된다.)

@XToOne(fetch = FetchType.LAZY)로 설정!


컬렉션은 필드에서 초기화하자!
컬렉션은 필드에서 바로 초기화 하는 것이 안전하다.
- null 문제에서 안전하다.


스프링 부트 설정 ( 엔티티(필드) -> 테이블(컬럼))
카멜케이스 -> 언더스코어

```




